import { analyze } from 'periscopic'

/**
 * @typedef {RegExp | string | ((value: string) => boolean)} Test
 */

/**
 * @typedef {Object} RecmaNextjsStaticPropsOptions
 * @property {string} [name='getStaticProps']
 * The name of the export to generate.
 * @property {Test[]} [include]
 * A list to filter identifiers to include in the generated function.
 *
 * This list may include strings which must be matched exactly, a regular expression to test
 * against, or a function that will be called with the value to test, and must return a boolean. By
 * default everything will be included.
 * @property {Test[]} [exclude]
 * The same as `include`, but matching values will be excluded instead.
 */

/**
 * Check if a value matches a test.
 *
 * @param {Test} test - The test to match.
 * @param {string} value - The value to match against the test.
 * @returns {boolean} Whether or not the value matches the test.
 */
function passTest(test, value) {
  if (typeof test === 'string') {
    return value === test
  }
  if (test instanceof RegExp) {
    return test.test(value)
  }
  return test(value)
}

/**
 * A recma plugin which exposes variables from the top-level scope in Next.js through
 * `getStaticProps`.
 *
 * @type {import('unified').Plugin<[RecmaNextjsStaticPropsOptions?], import('estree').Program>}
 */
const recmaNextjsStaticProps =
  ({ exclude, include, name = 'getStaticProps' } = {}) =>
  (ast) => {
    /**
     * @type {string[]}
     */
    const identifiers = []
    const { scope } = analyze(ast)

    for (const [id, node] of scope.declarations) {
      if (id === name) {
        return
      }

      // Always filter JSX functions generated by MDX.
      if (id === '_jsx' || id === '_jsxs' || id === '_Fragment') {
        continue
      }

      if (exclude && exclude.some((test) => passTest(test, id))) {
        continue
      }

      if (include && !include.some((test) => passTest(test, id))) {
        continue
      }

      // Weâ€™re not insterested in for example function or class declarations.
      if (
        node.type === 'ImportDefaultSpecifier' ||
        node.type === 'ImportSpecifier' ||
        node.type === 'VariableDeclaration'
      ) {
        identifiers.push(id)
      }
    }

    if (!identifiers.length) {
      return
    }

    ast.body.push({
      type: 'ExportNamedDeclaration',
      specifiers: [],
      declaration: {
        type: 'VariableDeclaration',
        kind: 'const',
        declarations: [
          {
            type: 'VariableDeclarator',
            id: { type: 'Identifier', name },
            init: {
              type: 'ArrowFunctionExpression',
              expression: true,
              generator: false,
              async: false,
              params: [],
              body: {
                type: 'ObjectExpression',
                properties: [
                  {
                    type: 'Property',
                    method: false,
                    shorthand: false,
                    computed: false,
                    kind: 'init',
                    key: { type: 'Identifier', name: 'props' },
                    value: {
                      type: 'CallExpression',
                      optional: false,
                      callee: {
                        type: 'MemberExpression',
                        computed: false,
                        optional: false,
                        object: { type: 'Identifier', name: 'JSON' },
                        property: { type: 'Identifier', name: 'parse' },
                      },
                      arguments: [
                        {
                          type: 'CallExpression',
                          optional: false,
                          callee: {
                            type: 'MemberExpression',
                            computed: false,
                            optional: false,
                            object: { type: 'Identifier', name: 'JSON' },
                            property: { type: 'Identifier', name: 'stringify' },
                          },
                          arguments: [
                            {
                              type: 'ObjectExpression',
                              properties: identifiers.sort().map((id) => ({
                                type: 'Property',
                                method: false,
                                shorthand: true,
                                computed: false,
                                kind: 'init',
                                key: { type: 'Identifier', name: id },
                                value: { type: 'Identifier', name: id },
                              })),
                            },
                          ],
                        },
                      ],
                    },
                  },
                ],
              },
            },
          },
        ],
      },
    })
  }

export default recmaNextjsStaticProps
